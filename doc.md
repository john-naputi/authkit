<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# authkit

```go
import "github.com/john-naputi/authkit"
```

## Index

- [type Clock](<#Clock>)
- [type Config](<#Config>)
- [type Deps](<#Deps>)
- [type MailSender](<#MailSender>)
- [type Server](<#Server>)
  - [func New\(cfg Config, deps Deps\) \*Server](<#New>)
  - [func \(s \*Server\) Handler\(\) http.Handler](<#Server.Handler>)
- [type Store](<#Store>)
- [type User](<#User>)


<a name="Clock"></a>
## type Clock

Clock is an injectable time source to enable deterministic tests.

```go
type Clock interface {
    Now() time.Time
}
```

<a name="Config"></a>
## type Config

Config holds runtime behaviors that differ by environment or host app.

```go
type Config struct {
    // AppOrigin is the canonical origin of the host (e.g., https://app.example.com).
    // Used to build absolute magic links and to drive default CORS.
    AppOrigin string

    // Env: "prod" | "staging" | "dev" | "test"
    Env string

    // CookieName is the session cookie name (e.g., "ak_session").
    CookieName string

    // CookieDomain optional; leave empty to use host-only cookie.
    CookieDomain string

    // DefaultRedirect used by /auth/callback when no redirect_path was stored.
    DefaultRedirect string

    // SessionTTL determines how long a session token remains valid.
    SessionTTL time.Duration

    // LinkTTL determines how long a one-time login link remains valid.
    LinkTTL time.Duration

    // Optional: Comma-separated overrides for allowed CORS origins. If empty,
    // AppOrigin is used. (See cors.go)
    CORSOverrides string
}
```

<a name="Deps"></a>
## type Deps

Deps are side\-effecting dependencies host apps must provide/compose.

```go
type Deps struct {
    Store Store
    Mail  MailSender
    Clock Clock
}
```

<a name="MailSender"></a>
## type MailSender

MailSender will be provided by the host \(e.g., Postmark/SES/Sendgrid\). For dev/test, a fake/no\-op sender is fine.

```go
type MailSender interface {
    // SendMagicLinkWithTTL returns a provider message ID if available (or empty string). Error must
    // reflect delivery failure; in non-prod environments, authkit will proceed
    // even if sending fails, so developers can copy magic links from responses
    // (behind an explicit header).
    SendMagicLinkWithTTL(ctx context.Context, to, link string, ttl time.Duration) (string, error)
}
```

<a name="Server"></a>
## type Server

Server is the public entry providing an http.Handler with all routes mounted.

```go
type Server struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func New

```go
func New(cfg Config, deps Deps) *Server
```

New creates a new Server instance. It does not start listening.

<a name="Server.Handler"></a>
### func \(\*Server\) Handler

```go
func (s *Server) Handler() http.Handler
```

Handler returns the http.Handler with CORS and basic security headers applied.

<a name="Store"></a>
## type Store

Store defines the persistence contract for AuthKit.

Implementations of Store provide the data layer for AuthKit’s passwordless magic\-link authentication flow. Each method corresponds to a well\-defined lifecycle event in user authentication, from link issuance to session validation and revocation.

The Store implementation must be safe for concurrent use and ensure uniqueness and expiry guarantees for tokens. Postgres is the reference implementation, but any backend \(SQL or key\-value\) can implement this interface as long as it honors the semantics below.

```go
type Store interface {

    // UpsertUserByEmail ensures that a user record exists for the given email.
    //
    // If a user with the given email already exists, it returns that user.
    // Otherwise, it creates a new user record and returns it.
    //
    // Typical behavior:
    //   - Normalize email (lowercase).
    //   - Ensure uniqueness on email.
    //   - Return a stable user ID for downstream references.
    //
    // This method is called when issuing a new magic link.
    UpsertUserByEmail(ctx context.Context, email string) (User, error)

    // CreateLoginLink inserts a new one-time magic-link token entry.
    //
    // The tokenHash is a SHA-256 hash of the magic link token (never the raw value).
    // redirectPath may be nil for default redirect behavior after login.
    // expiresAt defines the link’s lifetime.
    // Optional ip and ua fields may be used for audit logging or fraud detection.
    //
    // The token must be single-use and may not be reissued after expiration or consumption.
    CreateLoginLink(ctx context.Context, tokenHash []byte, userID string, redirectPath *string, expiresAt time.Time, ip *string, ua *string) error

    // GetLoginLinkByHash retrieves a pending login link record by its token hash.
    //
    // It returns the record’s ID, associated userID, redirectPath, expiration, and consumedAt timestamp.
    // If the token does not exist, has expired, or is invalid, an error should be returned.
    //
    // This method is used to validate inbound magic-link clicks before consumption.
    GetLoginLinkByHash(ctx context.Context, tokenHash []byte) (id string, userID string, redirectPath *string, expiresAt time.Time, consumedAt *time.Time, err error)

    // ConsumeLoginLink marks a magic link as used and returns its userID and redirectPath.
    //
    // Implementations must ensure atomicity:
    //   - If already consumed or expired, return an error.
    //   - Otherwise, set consumedAt = now and return the linked user and redirect path.
    //
    // This method finalizes the magic-link authentication flow.
    ConsumeLoginLink(ctx context.Context, id string) (userID string, redirectPath *string, err error)

    // CreateSession creates a new session record for a successfully authenticated user.
    //
    // The tokenHash is a SHA-256 hash of the session token stored in the secure cookie.
    // expiresAt defines the session’s natural expiry.
    // Optional ip and ua fields may be used for telemetry or session management UI.
    //
    // Session tokens should be long-lived relative to login links and can be revoked.
    CreateSession(ctx context.Context, userID string, tokenHash []byte, expiresAt time.Time, ip *string, ua *string) error

    // GetSessionByTokenHash returns the session associated with the given token hash.
    //
    // It should return the sessionID, userID, expiry, revokedAt (if any), and lastUsedAt.
    // If no valid session is found, or if it is expired/revoked, return an error.
    //
    // This method powers middleware validation for protected routes like GET /me.
    GetSessionByTokenHash(ctx context.Context, tokenHash []byte) (sessionID string, userID string, expiresAt time.Time, revokedAt *time.Time, lastUsedAt *time.Time, err error)

    // TouchSessionLastUsed updates the last-used timestamp for the given session.
    //
    // This may be called asynchronously or throttled (e.g., only once per 15 minutes)
    // to record user activity without excessive writes.
    TouchSessionLastUsed(ctx context.Context, sessionID string) error

    // RevokeSessionWithTokenHash invalidates a session identified by its token hash.
    //
    // Revoked sessions should be immediately considered invalid.
    // Typical use cases include explicit logout or admin termination.
    RevokeSessionWithTokenHash(ctx context.Context, tokenHash []byte) error

    // GetUserByID retrieves the user record for a given ID.
    //
    // Used by AuthKit when resolving /me and similar authenticated endpoints.
    GetUserByID(ctx context.Context, id string) (User, error)
}
```

<a name="User"></a>
## type User

User is the public shape the host must map to/from its DB layer. Keep all fields plain Go types to avoid pgx/sqlc/pgtype leakage.

```go
type User struct {
    ID        string
    Email     string
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
